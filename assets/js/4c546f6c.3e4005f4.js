"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[1064],{4376:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>o,default:()=>m,frontMatter:()=>c,metadata:()=>i,toc:()=>d});var a=t(7624),r=t(2172);const c={sidebar_position:1},o="Recurrent Transaction",i={id:"tech/backend/features/done/recurrent-transaction",title:"Recurrent Transaction",description:"Objetivo",source:"@site/docs/tech/backend/features/done/recurrent-transaction.md",sourceDirName:"tech/backend/features/done",slug:"/tech/backend/features/done/recurrent-transaction",permalink:"/docs/docs/tech/backend/features/done/recurrent-transaction",draft:!1,unlisted:!1,editUrl:"https://github.com/econominhas/docs/edit/master/docs/tech/backend/features/done/recurrent-transaction.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Onboarding",permalink:"/docs/docs/tech/backend/features/done/onboarding"},next:{title:"Transaction",permalink:"/docs/docs/tech/backend/features/done/transaction"}},s={},d=[{value:"Objetivo",id:"objetivo",level:2},{value:"Linha de raciocinio",id:"linha-de-raciocinio",level:2}];function u(e){const n={code:"code",h1:"h1",h2:"h2",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.M)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h1,{id:"recurrent-transaction",children:"Recurrent Transaction"}),"\n",(0,a.jsx)(n.h2,{id:"objetivo",children:"Objetivo"}),"\n",(0,a.jsx)(n.p,{children:"Criar algo que permita o usu\xe1rio criar transacoes que acontecem de tempos em tempos (recorrente), exemplo:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Recebimento de salario"}),"\n",(0,a.jsx)(n.li,{children:"Assinaturas a streamings"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"linha-de-raciocinio",children:"Linha de raciocinio"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Tentamos implementar uma vez, mas ficou muito complexo, imprevisivel e de dificil manutencao, seque o schema usado:"}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:'enum CaFormulaEnum {\n  EXACT_AMOUNT\n  MBWOPM /// MULTIPLY_BY_WEEKS_OF_PREV_MONTH, the amount is multiplied by the amount of weeks of the previous month\n  MBDOPM /// MULTIPLY_BY_DAYS_OF_PREV_MONTH, the amount is multiplied by the amount of days of the previous month\n  DPFET // DIFFERENT_PERCENTAGES_FOR_EACH_TRANSACTION, the "params" prop is an array of percentages matching each of the transactions that should be created. Using these parameters, the amount of the transaction will be multiplied by the percentage to get the final amount\n  CCB // CREDIT_CARD_BILL, sum the value of the transactions to get the amount\n\n  @@map("ca_formula_enum")\n}\n\nenum RecurrenceFrequencyEnum {\n  DAILY /// Every day\n  WEEKLY /// Every week\n  MONTHLY /// Once a month\n  SEMI_MONTHLY /// One month yes, another month no\n  QUARTERLY /// Once every 3 months\n  ANNUALLY /// Once a year @map("ANNUALLY")\n  SEMI_ANNUALLY /// Once every 6 months\n\n  @@map("recurrence_frequency_enum")\n}\n\nenum RecurrenceConditionsEnum {\n  IN_WEEKDAY /// Mon-Fri\n  IN_WEEKEND /// Sat-Sun\n  IS_EVEN_DAY /// Like 2, 4, 6\n  IS_ODD_DAY /// Like 1, 3, 5\n  NOT_HOLIDAY\n  IF_NOT_BEFORE /// If the day doesn\'t match the conditions, try previuoius days\n  IF_NOT_AFTER /// If the day doesn\'t match the conditions, try following days\n\n  @@map("recurrence_conditions_enum")\n}\n\n/// Contains all the user\'s recurrent transactions.\n/// The recurrent transactions are linked to the budget, this way the user can have a better control of which transactions he wants to execute.\nmodel RecurrentTransaction {\n  id                String              @id @db.Char(16)\n  accountId         String              @map("account_id") @db.Char(16)\n  budgetId          String              @map("budget_id") @db.Char(16)\n  isSystemManaged   Boolean             @map("is_system_managed") /// Define if the recurrent transaction is automatic controlled by the system, or if it\\\'s created and controled by the user\n  // Data to create the transaction\n  type              TransactionTypeEnum\n  name              String              @db.VarChar(30)\n  description       String              @db.VarChar(300)\n  amount            Int /// Can only be POSITIVE, the real amount is determined by the type OUT/CREDIT, then amount * -1\n  createdAt         DateTime            @default(now()) @map("created_at")\n  isSystemManagedT  Boolean             @map("is_system_managed_t") /// Same as "isSystemManaged". It exists because some RecurrentTransactions may be system managed, but the Trasactions created by this RecurrentTransaction aren\'t. An example of it it\'s the salary, we have a specific interface for the user to managed it, and it shouldn\'t be managed directly by the user like other RecurrentTransactions, but the transactions created by it are normal Transactions, that the user can edit freely.\n  // Transaction type=IN,OUT,CREDIT\n  categoryId        String?             @map("category_id") @db.Char(16) /// Only type=IN,OUT,CREDIT transactions have this column\n  cardId            String?             @map("card_id") @db.Char(16) /// Only type=IN,OUT,CREDIT transactions have this column\n  bankAccountId     String?             @map("bank_account_id") @db.Char(16) /// Only type=IN,OUT,CREDIT transactions have this column\n  // Transaction type=TRANSFER\n  bankAccountFromId String?             @map("bank_account_from_id") @db.Char(16) /// Only type=TRANSFER transactions have this column\n  bankAccountToId   String?             @map("bank_account_to_id") @db.Char(16) /// Only type=TRANSFER transactions have this column\n\n  account                   Account                    @relation(fields: [accountId], references: [id], onDelete: Cascade)\n  budget                    Budget                     @relation(fields: [budgetId], references: [id], onDelete: Restrict)\n  recurrentTransactionRules RecurrentTransactionRule[]\n  config                    Config?\n  // Transaction type=IN,OUT,CREDIT\n  category                  Category?                  @relation(fields: [categoryId], references: [id], onDelete: Restrict)\n  card                      Card?                      @relation(fields: [cardId], references: [id], onDelete: Restrict)\n  bankAccount               BankAccount?               @relation(name: "RecurrentTransactionBankAccount", fields: [bankAccountId], references: [id], onDelete: Restrict)\n  // Transaction type=TRANSFER\n  bankAccountFrom           BankAccount?               @relation(name: "RecurrentTransactionBankAccountFrom", fields: [bankAccountFromId], references: [id], onDelete: Restrict)\n  bankAccountTo             BankAccount?               @relation(name: "RecurrentTransactionBankAccountTo", fields: [bankAccountToId], references: [id], onDelete: Restrict)\n\n  @@map("recurrent_transactions")\n}\n\n/// Contains the recurrent transactions rules to be executed\nmodel RecurrentTransactionRule {\n  id                     String @id @db.Char(16)\n  recurrentTransactionId String @map("recurrent_transaction_id") @db.Char(16)\n\n  caFormula    CaFormulaEnum              @map("ca_formula")\n  caParams     String                     @map("ca_params") @db.VarChar /// JSON stringified prop to pass the params to calculate the amount\n  caConditions RecurrenceConditionsEnum[] @map("ca_conditions")\n\n  frequency   RecurrenceFrequencyEnum\n  fParams     String                     @map("f_params") @db.VarChar /// JSON stringified prop to pass the params to calculate the frequency\n  fConditions RecurrenceConditionsEnum[] @map("f_conditions")\n\n  recurrentTransaction RecurrentTransaction @relation(fields: [recurrentTransactionId], references: [id])\n\n  @@map("recurrent_transaction_rules")\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.img,{alt:"alt text",src:t(1212).c+"",width:"739",height:"830"}),"\n",(0,a.jsx)(n.img,{alt:"alt text",src:t(7516).c+"",width:"739",height:"629"}),"\n",(0,a.jsx)(n.img,{alt:"alt text",src:t(7672).c+"",width:"739",height:"735"}),"\n",(0,a.jsx)(n.img,{alt:"alt text",src:t(4908).c+"",width:"739",height:"875"}),"\n",(0,a.jsx)(n.img,{alt:"alt text",src:t(4772).c+"",width:"739",height:"707"}),"\n",(0,a.jsx)(n.img,{alt:"alt text",src:t(5504).c+"",width:"702",height:"706"})]})]})}function m(e={}){const{wrapper:n}={...(0,r.M)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(u,{...e})}):u(e)}},1212:(e,n,t)=>{t.d(n,{c:()=>a});const a=t.p+"assets/images/recurrent-transaction-1-7c3cf411ca88bd08f0bc35c812bd0c48.png"},7516:(e,n,t)=>{t.d(n,{c:()=>a});const a=t.p+"assets/images/recurrent-transaction-2-ceb13723c9de07b0d19dce40ecaa18b2.png"},7672:(e,n,t)=>{t.d(n,{c:()=>a});const a=t.p+"assets/images/recurrent-transaction-3-aef4accce441571e5ca12f2cc8b8fcf8.png"},4908:(e,n,t)=>{t.d(n,{c:()=>a});const a=t.p+"assets/images/recurrent-transaction-4-c7c62023840ff88fd06ec5d8ba9a4078.png"},4772:(e,n,t)=>{t.d(n,{c:()=>a});const a=t.p+"assets/images/recurrent-transaction-5-02d594622fbe98dccbd87023786f1da4.png"},5504:(e,n,t)=>{t.d(n,{c:()=>a});const a=t.p+"assets/images/recurrent-transaction-6-852f6294e7b57b0391792a2db6e789c4.png"},2172:(e,n,t)=>{t.d(n,{I:()=>i,M:()=>o});var a=t(1504);const r={},c=a.createContext(r);function o(e){const n=a.useContext(c);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),a.createElement(c.Provider,{value:n},e.children)}}}]);